[[ -n "$__playlist" ]] && return
declare -g __playlist=1

# source "${DRB_LIB:-/usr/local/lib}/general.sh"

# The functions starting with underscaore are intended for internal use only
PlaylistHelp() {
  tabs 4
  LogUnderline 'PlayList Help:' '#'
  Log "In order to generate a Windows Media Player playlist, it is necessary to have a mapping betwwen the path to the media files on this computer and how they are mapped on the Windows computer where you wish to view the media."
  Log "Unfortunately, creation of playlists for Mac and Linux clients is not currently supported."
  Log "To create the mapping, you need sudo permissions on this server."
  Log
  LogTable "$(Header "IMPORTANT:")\tThis help is generated by a library. The application showing you this likely has its own way of specifying drive mappings.
  \tThe method described here is in addition to the method used by the application. Normally, you'll want to choose one or the other, not both."  
  Log
  Log "$(Header "Usage:") CreatePlaylist FILES [MAPPINGS]"
  Log
  LogHeader "Parameters:"
  LogTable "\tFILES\tThe name of an array defined in the caller's scope containing a list of files to include in the playlist.
  \tMAPPINGS\t(optional) The name of an associative array (declare -A) containing a mapping of paths to drive letters."
  Log
  LogHeader "Environment Variables:"
  LogTable "\tPLAYLIST_STRICT\tSet to any value to have playlist generation be cancelled if a file is encountered for which there is no mount path (default: skip that file)
  \tPLAYLIST_TITLE\tThe name/title of the playlist
  \tPLAYLIST_FILE\tThe fully-qualified file name to save the playlist is (without extension). 
  \t\tIf not specified, the path will be assumed to be: $HOME/Videos/Playlists
  \t\tIf not specified, the file name will be \$PLAYLIST_TITLE.m3u8).
  \t\tNote: This value will be replaced with the fully-qualified file name of the new playlist once generated." 
  Log
  LogHeader "Document mapping:"
  Log "1. Run: sudo vim /etc/samba/smb.conf"
  Log "2. Scroll to the last section in the file where the shares are defined."
  Log "3. On the line immediately above the share name (in square braces), add a comment:"
  Log "\t# DriveLetter: [letter]"
  Log "4. Repeat for all volumes you have mapped"
  Log
  LogHeader "Example:"
  Log "\t# DriveLetter: Z"
  Log "\t[media]"
  Log "\tpath = /var/media"
  Log
  LogHeader "Notes:"
  Log "\t* If you have multiple clients that you want to make playlists for, it is necessary that they all map the same shares to the same drives."
  Log "\t* This is a last-ditch help message coming to you from a library. Whichever script you ran this from has the ability to specify share mappings in any way it wants to, but evidently chose not to. So if this seems prohibitively rigid to you, take it up with the people who wrote the script you're using."
}

_GetShareMap() {
  [ "$1" ] && return

  local -n pathMap="$1"
  local -r confFile="/etc/samba/smb.conf"
 
  # ${BASH_REMATCH[1]} = Result of previous regex match expression

  if [[ -f "$confFile" ]]; then
    # Step 1: Parse smb.conf
    currentDrive=""
    while IFS=$'\n' read -r line; do
      if [[ "$line" =~ ^#\ DriveLetter:\ ([A-Z]) ]]; then
        LogVerbose "Found drive letter in $confFile: ${BASH_REMATCH[1]}"
        currentDrive="${BASH_REMATCH[1]}"
      elif [[ "$line" =~ ^[[:space:]]*path[[:space:]]*=[[:space:]]*(.*) ]]; then
        LogVerbose "Found path in $confFile: ${BASH_REMATCH[1]}"
        [[ -n "$currentDrive" ]] \
          && pathMap["${BASH_REMATCH[1]}"]="$currentDrive" \
          && currentDrive=""
      fi
    done < "$confFile"
  
    for path in "${!pathMap[@]}"; do
      Log "Drive Mapping: ${pathMap["$path"]} = $path"
    done
  fi

  [ "${#pathMap[@]}" == 0 ] && return 1 || return 0
}

GetWinPath() {
  [[ "$1" ]] || return 99

  local -n _shareMap="$1"
  local _linuxPath="$2"

  for _mapPath in "${!_shareMap[@]}"; do
    if [[ "$_linuxPath" =~ ^"$_mapPath" ]]; then
      printf "%s" "$(echo -n "$_linuxPath" | sed -E -e "s|$_mapPath|${_shareMap[$_mapPath]}:|" -e 's|/|\\|g')"
      return 0
    fi
  done
  return 1
}

# Creates a Windows Media Player-compatible playlist file
# + $1 = Name of an array containing media file namnes defined in parent scope.
# + $2 = (optional) Name of an assoc array containing mapping of local paths to mapped drive letters on Windows clients
# - return = 0 = Playlist created successfully.
# -          1 = Configuration error. Print stdout to the display
#            2 = $PLAYLIST_STRICT was set and generation encountered a file in an unmapoped location (message printed to stderr)
#            99 = It doesn't matter what I write here because this code means that you didn't bother to read any of this!
CreatePlaylist() {
  [ -z "$1" ] && return 99

  local -n files="$1"

  if [ -z "$2" ]; then
    local -A shareMap
    if ! _GetShareMap "shareMap"; then
      PlaylistHelp
      return 1
    fi
  else
    local -n shareMap="$2"
  fi

  if [[ ${#shareMap[@]} == 0 ]]; then
    LogError "$(ColorText LRED "FATAL: No drive mapping could be inferred through any available means.")"
    return 20
  fi

  for k in "${!shareMap[@]}"; do 
    LogVerbose "$k â†’ ${shareMap[$k]}"; 
  done
  
  # Step 3: Playlist output
  local title="${PLAYLIST_TITLE:-playlist}"
 
  local -r ext='m3u8'
  local -r defaultPath="$HOME/Videos/Playlists"
  local outFile
  if [ -z "$PLAYLIST_FILE" ]; then
    outFile="$defaultPath/$title.$ext"
  elif [[ "$PLAYLIST_FILE" == *.$ext ]]; then
    [[ "$PLAYLIST_FILE" == */* ]] \
      && outFile="$PLAYLIST_FILE" \
      || outFile="$defaultPath/$PLAYLIST_FILE"
  else
    outFile="$PLAYLIST_FILE/$title.$ext"
  fi

  LogVerbose -l "Attempting to write: $outFile"

  # Don't silently overwrite older playlist file
  if [[ -e "$outFile" ]]; then
    Log -ln "$outFile exists! Overwrite [y/N]? "
    read -n1 overwrite; echo
    [[ ${overwrite,,} == y ]] || return 2
  fi

  # Sanitize $outFile
  local outDir="$(dirname "$outFile")"
  [[ ! -d "$outDir" ]] && mkdir -p "$outDir"
  unset outDir

  {
    printf '\xEF\xBB\xBF'    # UTF-8 Byte Order Mark (BOM)
    printf "%s\r\n" '#EXTM3U'
    printf "%s\r\n" "#${title}.${ext}"
  
    local winpath fileAdded=false

    for f in "${files[@]}"; do
      winpath="$(GetWinPath 'shareMap' "$f")"
      if [[ $? == 0 ]]; then
        # Escape XML chars
        # winpath="$(XmlEncode "$winpath")"
        printf "%s\r\n" "$winpath"
        fileAdded=true
      else
        LogError "$(ColorText LRED "File $f is in a location with no mapping from Windows clients [skipping]")"
        [ "$PLAYLIST_STRICT" ] && return 2 || continue
      fi
    done  
  } > "$outFile"

  if [[ $? != 0 ]]; then
    if [[ -w "$outFile" ]]; then
      LogError "There was an error writing the playlist file... Directory permissions seem fine. I don't know what's wrong!"
      rm -f "$outFile"
    else
      LogError "Playlist creation failed: You don't have write permission to the playlist directory."
    fi
    return 1
  elif [[ $fileAdded != true ]]; then
    LogError "The playlist failed to be created because none of the selected files are on Windows-mapped shares."
    rm -f "$outFile"
    return 1
  fi

  PLAYLIST_FILE="$outFile"
  PLAYLIST_WINFILE="$(GetWinPath 'shareMap' "$outFile")"
  return 0
}
